/* automatically generated by rust-bindgen */

use libc::{c_ulong, c_long, c_ushort, c_short, c_uchar, c_schar, c_int};

//TODO consider removing as these constants aren't even used in different versions of the code
// pub const UB4MAXVAL: c_uint = 4294967295;
// pub const SB4MAXVAL: c_uint = 2147483647;
// pub const UB2MAXVAL: c_uint = 65535;
// pub const SB2MAXVAL: c_uint = 32767;
// pub const UB1MAXVAL: c_uint = 255;
// pub const SB1MAXVAL: c_uint = 127;
// pub const RANDSIZL: c_uint = 4;
// pub const RANDSIZ: c_uint = 16;

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub type ub4 = c_ulong;
#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub type sb4 = c_long;
#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub type ub2 = c_ushort;
#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub type sb2 = c_short;
#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub type ub1 = c_uchar;
#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub type sb1 = c_schar;
#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub type word = c_int;

#[repr(C)]
#[derive(Debug, Copy)]
#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct randctx {
    pub randcnt: ub4,
    pub randrsl: [ub4; 16usize],
    pub randmem: [ub4; 16usize],
    pub randa: ub4,
    pub randb: ub4,
    pub randc: ub4,
}
impl Clone for randctx {
    fn clone(&self) -> Self {
        *self
    }
}
#[allow(dead_code)]
#[allow(non_camel_case_types)]
extern "C" {
    pub fn irandinit(r: *mut randctx, flag: word);
}
#[allow(dead_code)]
#[allow(non_camel_case_types)]
extern "C" {
    pub fn isaac(r: *mut randctx);
}

#[test]
fn bindgen_test_layout_randctx() {
    assert_eq!(::std::mem::size_of::<randctx>(),
               144usize,
               concat!("Size of: ", stringify!(randctx)));
    assert_eq!(::std::mem::align_of::<randctx>(),
               4usize,
               concat!("Alignment of ", stringify!(randctx)));
    assert_eq!(unsafe { &(*(0 as *const randctx)).randcnt as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(randctx),
                       "::",
                       stringify!(randcnt)));
    assert_eq!(unsafe { &(*(0 as *const randctx)).randrsl as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(randctx),
                       "::",
                       stringify!(randrsl)));
    assert_eq!(unsafe { &(*(0 as *const randctx)).randmem as *const _ as usize },
               68usize,
               concat!("Alignment of field: ",
                       stringify!(randctx),
                       "::",
                       stringify!(randmem)));
    assert_eq!(unsafe { &(*(0 as *const randctx)).randa as *const _ as usize },
               132usize,
               concat!("Alignment of field: ",
                       stringify!(randctx),
                       "::",
                       stringify!(randa)));
    assert_eq!(unsafe { &(*(0 as *const randctx)).randb as *const _ as usize },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(randctx),
                       "::",
                       stringify!(randb)));
    assert_eq!(unsafe { &(*(0 as *const randctx)).randc as *const _ as usize },
               140usize,
               concat!("Alignment of field: ",
                       stringify!(randctx),
                       "::",
                       stringify!(randc)));
}

#[test]
//TODO Create a test based off the Vernam and Ceaser cipher examples in Rosetta code
//https://rosettacode.org/wiki/The_ISAAC_Cipher#C
fn test_isaac_with_secret() {}
